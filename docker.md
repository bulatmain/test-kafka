# Краткое описание Docker'а

Думаю, всем известно, что *Docker* - это платформа для разработки, доставки и запуска приложений в контейнерах. Контейнер представляет собой запускаемый экземпляр образа *Docker*. Он включает в себя приложение и все его зависимости, упакованные в изолированную среду.

У *Docker'а* есть еще *Docker Compose* для запуска нескольких контейнеров и *Docker Swarm* для оркестрации контейнеров и тд, но в нашем проекте эти функции выполняет *Kubernetes*.

Чтобы запустить контейнер в *Docker'е* нужен *image*(образ), который можно самому создать либо стянуть из *Docker hub'а*. 

Чтобы создать собственный образ, нужно написать *Dockerfile*, вроде как, с достаточно простым синтаксисом.

Вот пример *Dockerfile'а* для образа с простой *Linux* для запуска *С++* кода.
```docker
FROM alpine:latest

RUN apk update && apk upgrade

RUN apk add g++ cmake make

COPY . /home

WORKDIR /home

RUN cmake . && make
```
Описание команд:
- `FROM` указывает на образ, который мы хотим откуда-то стянуть. Допустим, в этом примере это образ `alpine`. ***Alpine*** - лёгковесный дистрибутив *Linux*. Туда спокойно можно было написать `ubuntu`. Ну и не трудно догадаться, что `latest` - это версия. По дефолту и так стоит `latest`, так что необязательно его писать.

- `RUN` запускает команды во время создания образа. Сначала мы обновляем, а потом скачиваем необходимые пакеты для *C++*. `apk` и `apk add` являются аналогами `apt` и `apt install` в *Ubuntu* соответственно.

- `COPY` копирует все файлы, которые лежать рядом с *Dockerfile'ом* в контейнер. 
- `WORKDIR` устанавливает рабочую директорию. При запуске контейнера вы сразу окажетесь в этой директории.

Так же может пригодиться команда `CMD`, которая выполняет команды после запуска контейнера. Вот такое у нее применение
```docker
CMD ["./main"]
```
## Разница `CMD` и `RUN`
То, что написано в кавычках, будет выполнено уже после каждого запуска контейнера. Поэтому установка пакетов должна происходить командой `RUN`, чтобы при каждом запуске контейнера не ждать загрузку всего, ведь `RUN` выполняется только один раз. И еще, если вы что-то поменяете в *C++* файле и нужно будет пересобрать образ, то `RUN` все это кэширует и не будет опять долго все это скачивать.

Ну вот команды, смысл которых я понял, там есть еще несколько команд, но эти основные.

После того как *Dockerfile* написан в консоли пишем
```bash
docker build [OPTIONS] PATH
```
Ну основной ключ `-t`, чтобы потом не обращаться к этому образу через его ID. Например, находимся в той же директории, где и *Dockerfile* и пишем
```bash
docker build -t observer .
```
После того, как создали наш образ можем посмотреть список образов командой
```bash
docker images
```
Чтобы запустить контейнер воспользуемся командой
```bash
docker run [OPTIONS] IMAGE [COMMAND] [ARG...]
```
Где `[OPTIONS]` - ключи, `IMAGE` - имя(*ID*) образа, `[COMMAND]` - команда, которую нужно запустить при запуске контейнера и ее аргументы `[ARG ...]`. Ну команды можно писать и в *Dockerfile*.

Ну самые популярные ключи будут:
- `-i` - интерактивный режим, то есть можно взаимодействовать, к примеру, с Linux
- `-d` - запустить контейнер на заднем фоне.

## Взаимодействие с *Docker Hub*

Для отправки кому-то своего образа, нужно провзаимодействовать с *Docker Hub*.
Чтобы загрузить образ на *Docker Hub*, нужно:
1) Создать учетную запись на *Docker Hub*;
2) Авторизоваться в *Docker Hub* через командную строку;
    ```bash
    docker login -u username -p password
    ```
3) Создать тэг для своего образа
    ```bash
    docker tag local_image_name username/image_name:version
    ```
4) Загрузить образ на *Docker Hub*
    ```bash
    docker push username/image_name:version
    ```

Также можно скачать образ с *Docker Hub'a*
```bash
docker pull owner_username/image_name:version
```